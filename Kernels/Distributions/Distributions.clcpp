
#ifndef CLG_DISTRIBUTIONS_CLCPP
#define CLG_DISTRIBUTIONS_CLCPP



struct PRNG_ISAAC
{
    isaac_state state;
    PRNG_ISAAC(const uint& seed)
    {
        isaac_seed(&state, seed);
    }

    float generate_float()
    {
        return isaac_float(&state);
    }
};


struct PRNG_KISS99
{
    kiss99_state state;
    PRNG_KISS99(const uint& seed)
    {
        kiss99_seed(&state, seed);
    }

    float generate_float()
    {
        return kiss99_float(&state);
    }
};


struct PRNG_LCG6432
{
    lcg6432_state state;
    PRNG_LCG6432(const uint& seed)
    {
        lcg6432_seed(&state, seed);
    }

    float generate_float()
    {
        return lcg6432_float(&state);
    }
};


struct PRNG_LFIB
{
    lfib_state state;
    PRNG_LFIB(const uint& seed)
    {
        lfib_seed(&state, seed);
    }

    float generate_float()
    {
        return lfib_float(&state);
    }
};

struct PRNG_MRG31K3P
{
    mrg31k3p_state state;
    PRNG_MRG31K3P(const uint& seed)
    {
        mrg31k3p_seed(&state, seed);
    }

    float generate_float()
    {
        return mrg31k3p_float(&state);
    }
};

struct PRNG_MRG63K3A
{
    mrg63k3a_state state;
    PRNG_MRG63K3A(const uint& seed)
    {
        mrg63k3a_seed(&state, seed);
    }

    float generate_float()
    {
        return mrg63k3a_float(&state);
    }
};

struct PRNG_MSWS
{
    msws_state state;
    PRNG_MSWS(const uint& seed)
    {
        msws_seed(&state, seed);
    }

    float generate_float()
    {
        return msws_float(&state);
    }
};

struct PRNG_MT19937
{
    mt19937_state state;
    PRNG_MT19937(const uint& seed)
    {
        mt19937_seed(&state, seed);
    }

    float generate_float()
    {
        return mt19937_float(&state);
    }
};

struct PRNG_MWC64X
{
    mwc64x_state state;
    PRNG_MWC64X(const uint& seed)
    {
        mwc64x_seed(&state, seed);
    }

    float generate_float()
    {
        return mwc64x_float(&state);
    }
};

struct PRNG_PCG6432
{
    pcg6432_state state;
    PRNG_PCG6432(const uint& seed)
    {
        pcg6432_seed(&state, seed);
    }

    float generate_float()
    {
        return pcg6432_float(&state);
    }
};

struct PRNG_PHILOX2X32_10
{
    philox2x32_10_state state;
    PRNG_PHILOX2X32_10(const uint& seed)
    {
        philox2x32_10_seed(&state, seed);
    }

    float generate_float()
    {
        return philox2x32_10_float(&state);
    }
};

struct PRNG_RAN2
{
    ran2_state state;
    PRNG_RAN2(const uint& seed)
    {
        ran2_seed(&state, seed);
    }

    float generate_float()
    {
        return ran2_float(&state);
    }
};

struct PRNG_TINYMT32
{
    tinymt32_state state;
    PRNG_TINYMT32(const uint& seed)
    {
        tinymt32_seed(&state, seed);
    }

    float generate_float()
    {
        return tinymt32_float(&state);
    }
};

struct PRNG_TINYMT64
{
    tinymt64_state state;
    PRNG_TINYMT64(const uint& seed)
    {
        tinymt64_seed(&state, seed);
    }

    float generate_float()
    {
        return tinymt64_float(&state);
    }
};

struct PRNG_WELL512
{
    well512_state state;
    PRNG_WELL512(const uint& seed)
    {
        well512_seed(&state, seed);
    }

    float generate_float()
    {
        return well512_float(&state);
    }
};



template <typename PRNG_state>
void UniformSample(PRNG_state& state, float min, float max, uint N, float* res)
{
    for (int i = 0; i < N; i++)
    {
        res[i] = rng.generate_float();
    }
}

template <typename PRNG_state>
bool BernoulliTrial(PRNG_state& state, float p)
{
    float r;
    UniformSample(state, 0.0f, 1.0f, 1, &r);
    return r < p;
}

template <typename PRNG_state>
uint BinomialSample(PRNG_STATE& state, const uint N, float p)
{
    float uSample = 1.f;
    uint count = 0;
    for (uint i = 0; i < N; i++)
    {
        UniformSample(state, 0, 1, 1, &uSample);
        // printf("%f\n", uSample);
        if (uSample < p)
        {
            count++;
        }
    }
    return count;
}
template <typename PRNG_state>
float PoissonSample(PRNG_state* state, float lambda)
{
    float x = 0;
    float p = -lambda;
    float s = 1;
    float u;
    // printf("p: %e, lbd: %f", p, lambda);
    while(s > p)
    {
        UniformSample(state, 0, 1, 1, &u);
        x++;
        s = s + log(u);
    }
    // printf("x: %f\n", x);
    return x-1;
}

#endif